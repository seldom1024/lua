---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by seldom.
--- DateTime: 2020/5/1 17:01
---

--- 创建一个 协同程序
co1 = coroutine.create(
        function(i)
            print(i)
        end
)

--- 启动
coroutine.resume(co1, 1);
--- 查看状态
print(coroutine.status(co1))


print("======================")
--- 创建 coroutine，返回一个函数，一旦你调用这个函数，就进入 coroutine，和 create 功能重复
co2 = coroutine.wrap(
        function (i)
            print(i)
        end
)
co2(1)



print("=======================")
co3 = coroutine.create(
        function()
            for i = 1, 10 do
                print(i)
                if i%3==0 then
                    print(coroutine.status(co3))
                    --- 返回正在跑的 coroutine，一个 coroutine 就是一个线程，当使用running的时候，就是返回一个 corouting 的线程号
                    print(coroutine.running())
                end
            end
 end
)
--- 只启动一次
coroutine.resume(co3)
coroutine.resume(co3)
coroutine.resume(co3)

print(coroutine.status(co3))
print(coroutine.running())
print("========================")


---
---coroutine.running就可以看出来,coroutine在底层实现就是一个线程。
---当create一个coroutine的时候就是在新线程中注册了一个事件。
---当使用resume触发事件的时候，create的coroutine函数就被执行了，当遇到yield的时候就代表挂起当前线程，等候再次resume触发事件。
---接下来我们分析一个更详细的实例：
---
function foo(a)
    print("a in foo:", a)
    return coroutine.yield(2 * a) -- 返回 2*a 的值
end

co = coroutine.create(
        function(a, b)
            print("第一次输出：", a, b)
            local r = foo(a + 1)

            print("第二次输出：", r)
            local r, s = coroutine.yield(a + b, a -b) -- a, b 的值为第一次调用协同程序时传入

            print("第三次输出：", r, s)
        end
)

print("main", coroutine.resume(co, 1, 10)) -- true, 4
print("--分割线----")
print("main", coroutine.resume(co, "r")) -- true 11 -9
print("---分割线---")
print("main", coroutine.resume(co, "x", "y")) -- true 10 end
print("---分割线---")
print("main", coroutine.resume(co, "x", "y")) -- cannot resume dead coroutine
print("---分割线---")
---
--- 以上实例接下如下：
--- 调用resume，将协同程序唤醒,resume操作成功返回true，否则返回false；
--- 协同程序运行；
--- 运行到yield语句；
--- yield挂起协同程序，第一次resume返回；（注意：此处yield返回，参数是resume的参数）
--- 第二次resume，再次唤醒协同程序；（注意：此处resume的参数中，除了第一个参数，剩下的参数将作为yield的参数）
--- yield返回；
--- 协同程序继续运行；
--- 如果使用的协同程序继续运行完成后继续调用 resume方法则输出：cannot resume dead coroutine
--- resume和yield的配合强大之处在于，resume处于主程中，它将外部状态（数据）传入到协同程序内部；而yield则将内部的状态（数据）返回到主程中。
---


--- 生产者-消费者问题
local newProducer

--- 接受信息
function receive()
    local status, value = coroutine.resume(newProducer)
    return value;
end

--- 发送消息
function send(x)
    coroutine.yield(x)      -- x表示需要发送的值，值返回以后，就挂起该协同程序
end

function producer()
    local i = 1
    while true do
        i = i + 1
        send(i)     -- 将生产的物品发送给消费者
    end
end

function consumer()
    while true do
        local i = receive()     -- 从生产者那里得到物品
        print(i)
    end
end


--- 启动
newProducer = coroutine.create(producer)
consumer()